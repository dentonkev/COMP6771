# 6771 Notes

### General Info

Lecturer: Hayden Smith   
Course email: cs6771@cse.unsw.edu.au

- Assignments: 70%
- Final: 30%

Documentation: https://en.cppreference.com/w/

`git reset --soft HEAD~1`

## Types
```c
int val
double val
char ch
bool b
// #include<string>
std::string str = "string"
auto  
const 
```

### Type conversion
```c
auto const val = 0;
auto const val = static_cast<double>(i);
```

## Functions
```c
int main()
{
std::cout << "Hello, World!\n";
}

auto main() -> int
{
std::cout << "Hello, world!\n";
}
```

```c
// Default arguments (always at the end)
#include <string>

std::string rgb(short r = 0, short g = 0, short b = 0) {
    (void)r;
    (void)g;
    (void)b;
    return "";
}

int main() {
    rgb(); // rgb(0, 0, 0);
    rgb(100); // Rgb(100, 0, 0);
    rgb(100, 200); // Rgb(100, 200, 0)
    // rgb(100, , 200); // error
}
```

### Function overloading
```c
#include <catch2/catch.hpp>

auto square(int const x) -> int
{
    return x * x;
}

auto square(double const x) -> double
{
    return x * x;
}

TEST_CASE()
{
    CHECK(square(2) == 4);
    CHECK(square(2.0) == 4.0);
    CHECK(square(2.0) != 4);
}
```
## References
```c
TEST_CASE()
{
    auto i = 1;
    auto& j = i;
    j = 3; 
    CHECK(i == 3); // true
}
```

## Catch2
- A `TEST_CASE` is a uniquely-named scope that has the context for our test framework, and will keep track of all the `CHECK`s and `REQUIRE`s that pass/fail.
- `CHECK` will evaluate an expression and report if it is `false`, but the program will continue to
run.
- `REQUIRE` is closer to an `assert` than a check, in that it terminates the test case, but unlike an `assert`, it will gracefully exit the test case, rather than terminate on the spot. Subsequent test cases are still execute, so unlike an assert, it only aborts a portion of the program, rather than the whole program.

```c
TEST_CASE("Addition works correctly") {
    CHECK(add(1, 1) == 2);
    CHECK(add(2, 2) == 4);
    CHECK(add(2, 2) == 5); // This will fail but the test will continue
    REQUIRE(add(3, 3) == 6); // This will terminate the test if it fails
}
```

- `SECTION` blocks allow us to write setup code for our checks. Every `SECTION` will run all the
code in the `SECTION` block that it's enclosed in, all the way back up to the `TEST_CASE`. This
means that we can modify what we're testing in one section, and still get the same state we
started in all following states at the same level!

```c
TEST_CASE("Factorial calculations", "[factorial]") {
    SECTION("Factorial of 0 is 1") {
        REQUIRE(factorial(0) == 1);
    }
    SECTION("Factorial of 1 is 1") {
        REQUIRE(factorial(1) == 1);
    }
}
```

## STL: Standard Template Library
STL is an architecture for managing **generic and abstract** collections of data with algorithms
- Containers store data, don't know about algorithms
- Algorithms manipulate values referenced by iterators, don't know about containers

## Containers
### Sequential Containers
Organises a finite set of objects into a strict linear arrangement.
<img src="./images/std.png" width='400px' height='auto'>  

### Ordered Associative Containers
Organises a finite set of objects into a strict linear arrangement.
<img src="./images/std2.png" width='500px' height='auto'>  

### Unordered Associative Containers
Provide fast retrieval of data based on keys. The keys are hashed.
<img src="./images/std3.png" width='500px' height='auto'>  

### Container Performance
Different containers have different time complexity of the same operation.

<img src="./images/pf.png" width='350px' height='auto'>  

## STL Iterators
Iterators is an abstract notion of a pointer
- Abstract container data as a sequence of objects (i.e. linear)
- connect containers to algorithms

<img src="./images/it.png" width='500px' height='auto'>  

- `a.begin()`: abstractly "points" to the first element
- `a.end()`: abstractly "points" to one past the last element
   - `a.end()` is not an invalid iterator value

### Constness & Reverse

```cpp
std::vector<int> ages;
ages.push_back(18);
ages.push_back(19);
ages.push_back(20);

// type of iter would be std::vector<int>::iterator
for (auto iter = ages.begin(); iter != ages.end(); ++iter) {
    (*iter)++; // OK
}
// type of iter would be std::vector<int>::const_iterator
for (auto iter = ages.cbegin(); iter != ages.cend(); ++iter) {
    //(*iter)++; // NOT OK
}
// type of iter would be std::vector<int>::reverse_iterator
for (auto iter = ages.rbegin(); iter != ages.rend(); ++iter) {
    std::cout << *iter << "\n"; // prints 20, 19, 18
}
```

## Iterator Categories
<img src="./images/cat.png" width='500px' height='auto'>  
<img src="./images/cat2.png" width='500px' height='auto'>  

## Stream Iterators
```cpp
std::ifstream in("data.in");

std::istream_ iterator<int> begin(in);
std::istream_iterator<int> end;

std::cout << *begin++ << "\n"; // read the first int
++begin; // skip the 2nd int
std::cout << *begin++ << "\n"; // read the third int

while (begin != end) {
    std::cout << *begin++ << "\n"; // read and print rest
}
```

## STL Algorithms
STL Algorithms are functions that execute an algorithm on an abstract notion of an iterator. 

```cpp
int main() {
    std::vector<int> nums { 1, 2, 3, 4, 5 };
    auto sum = 0;
    for (auto it = nums.begin(); it != nums.end(); ++it) {
        sum += *it;
    }
    std::cout << sum << "\n";
}
``` 
```cpp
int main() {
    std::vector<int> nums { 1, 2, 3, 4, 5 };
    int sum = std::accumulate(nums.begin(), nums.end(), 0);
    std::cout << sum << "\n";
}
```

## Lambda Functions
```cpp
// General Format
// capture - allows variables to be in scope of lambda function
[capture] (parameters) -> return {
    body
}

[](card const c) -> bool {
    return c.colour == 4;
}
```

```cpp
void add_n(std::vector<int>& v, int n) {
    std::for_each(v.begin(), v.end(), 
                [n] (int& val) { val = val + n; }
    );
}

int main() {
    std::vector<int> v{1,2,3};
    add_n(v, 3);
    // vector = {4, 5, 6}
}
```